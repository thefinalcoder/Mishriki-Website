<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>10/8/2024 - Hacker Blog</title>
  <style>
    /* Base Styles */
    body {
      background-color: black;
      color: white;
      font-family: "Courier New", monospace;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
      line-height: 1.6;
    }
    h1, h2, h3 {
      border-left: 5px solid white;
      padding-left: 10px;
      margin-top: 1.2em;
    }
    p, li {
      line-height: 1.6;
    }
    .terminal {
      background-color: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 5px;
      border: 1px solid white;
      margin: 20px 0;
    }
    .cursor {
      display: inline-block;
      width: 10px;
      height: 20px;
      background-color: white;
      animation: blink 0.8s infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    embed {
      border: 2px solid white;
      border-radius: 5px;
      width: 50%;
      height: 800px;
      display: block;
      margin: 20px auto;
    }

    /* Mobile Responsiveness */
    @media only screen and (max-width: 768px) {
      body {
        padding: 10px;
      }
      h1 {
        font-size: 1.8em;
      }
      h2 {
        font-size: 1.5em;
      }
      h3 {
        font-size: 1.3em;
      }
      embed {
        width: 90%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <main>
    <article>
      <header>
        <h1>10/8/2024 - First Blog</h1>
      </header>
      <section class="terminal">
        <p><strong>root@hacker_blog:~$</strong> <span>Hello World!<span class="cursor"></span></span></p>
      </section>
    </article>

    <article>
      <header>
        <h1>10/8/2024 - QuickSort Analysis</h1>
      </header>
      <section>
        <p>Welcome back! Today, I’m diving into a key topic in computer science: sorting algorithms. More specifically, I’m analyzing QuickSort, a widely used divide-and-conquer sorting algorithm.</p>
      </section>
      <section>
        <h2>Why Sorting Matters</h2>
        <p>Sorting algorithms play a fundamental role in computing. Efficient sorting leads to better performance in database indexing, search engine optimization, and even scientific computing. That’s why understanding the trade-offs between sorting algorithms is essential.</p>
      </section>
      <section>
        <h2>Understanding QuickSort</h2>
        <p>QuickSort is an efficient, comparison-based sorting algorithm developed by Tony Hoare in 1959. It employs a divide-and-conquer approach, where a pivot element is selected, and the array is partitioned into two subarrays. The process is then applied recursively.</p>
      </section>
      <section>
        <h3>Algorithm Breakdown:</h3>
        <div class="terminal">
          <ol>
            <li><strong>Divide:</strong> Select a pivot and partition the array into elements smaller and greater than the pivot.</li>
            <li><strong>Conquer:</strong> Recursively apply QuickSort to the left and right subarrays.</li>
            <li><strong>Combine:</strong> Once sorted, merge the partitions back together.</li>
          </ol>
        </div>
      </section>
      <section>
        <h2>Efficiency and Complexity</h2>
        <p>QuickSort’s efficiency largely depends on pivot selection. On average, it runs in O(n log n) time, making it faster than other comparison-based sorts like MergeSort for many use cases. However, in the worst case (when the pivot is always the smallest or largest element), it degrades to O(n²).</p>
      </section>
      <section>
        <h2>Best Use Cases</h2>
        <ul>
          <li>General-purpose sorting in Python, Java, and C++.</li>
          <li>Optimized performance with random or partially sorted data.</li>
          <li>In-place sorting requiring minimal extra space.</li>
        </ul>
      </section>
      <section>
        <h2>Limitations</h2>
        <p>QuickSort may not be the best choice when data is already nearly sorted. MergeSort, which has a stable O(n log n) runtime, can be more reliable in such cases.</p>
      </section>
      <section>
        <h2>Full Paper</h2>
        <p>For a detailed analysis, including pseudo-code, proof of correctness, and performance analysis, check out my full paper below:</p>
        <embed src="CS460_Midterm1_Eli_Mishriki.pdf" type="application/pdf">
      </section>
      <section>
        <p>That’s it for today’s post! Let me know what you think about QuickSort, and feel free to share your favorite sorting algorithm!</p>
      </section>
    </article>
  </main>
</body>
</html>

